------------------------------------------------------------------
Шина сообщений для корутин
Язык: С.
Время: 2 недели.
------------------------------------------------------------------

Есть объект "шина сообщений", как на материнской плате. В шине
можно открывать каналы, в которые можно засылать простые
сообщения.

Нужно реализовать эту шину с поддержкой корутин.

Корутина, так же известная как сопрограмма, легкий поток,
виртуальный поток, "зеленый" поток, файбер - это единица
исполнения кода. Она выполняет линейный код и имеет стек, так же
как настоящие потоки, но корутина не управляется ядром. Напротив,
корутины - это объекты пользовательского пространства, и их
шедулинг целиком происходит здесь же. Самый простой сценарий, это
когда один поток имеет внутри много корутин и переключается между
ними по очереди.

Корутины уже реализованы, и идея шины сообщений весьма проста.
Основная сложность задачи - сделать шину совместимой с корутинами.

Например, канал в шине имеет максимальную емкость. Когда корутина
пытается послать сообщение в канал, который уже полон, корутина
должна быть поставлена на паузу, пока в канале не освободится
место.

Тесты находятся в test.c. Шаблон реализации - в corobus.h и
corobus.c.


Правила:

- Реализация должна строго следовать поведению, определенному в
  комментариях в corobus.h.

- Все тесты должны пройти.

- Код должен собираться успешно с данными флагами компилятора:
  `-Wextra -Werror -Wall -Wno-gnu-folding-constant`.


Ограничения:

- Глобальные переменные запрещены (кроме уже существующих).

- Утечки памяти запрещены. Для их поиска можно использовать
  модуль utils/heap_help. Показать репорты с нулем утечек от
  Valgrind или ASAN не достаточно - они часто пропускают утечки.

- Нельзя менять test.c, libcoro.c, libcoro.h.


Послабления:

- Можно считать, что malloc()/realloc()/calloc() никогда не
  возвращают NULL.

- Можно использовать интрузивный список из utils/rlist.h.


Советы:

- Попытайтесь почитать libcoro_test.c и test.c, чтобы посмотреть,
  как корутины используются. Попробуйте запустить libcoro_test.c,
  добавит принтов, воспользоваться отладчиком, чтобы понять, как
  что работает.

- Почитайте libcoro.h, чтобы узнать, какое API корутин вам
  доступно, и что для вашего решения будет полезно.

- Разобравшись, как работают libcoro корутины, попробуйте
  спроектировать дизайн своей шины. В голове, затем записав как
  текст. Не начинайте кодинг до того, как понимаете, что именно
  кодить. Всегда сначала дизайн, потом код.

- Реализуйте сначала try_send, try_recv, и прочие try. Они не
  будут блокировать текущую корутину, а потому довольно
  тривиальны. Затем попробуйте сделать send через try_send, recv
  через try_recv, и тд.


Варианты решения:

- 15 баллов: пройти все тесты.

- +5 баллов: реализовать broadcast. Чтобы включить тесты на
  broadcast, вам следует определить макрос NEED_BROADCAST в 1 в
  corobus.h. Тесты должны пройти. В corobus.h вы найдете broadcast
  функции и описания того, что они должны делать.

- +5 баллов: векторные send/recv. Чтобы включить соответствующие
  тесты, вам следует определить макрос NEED_BATCH в 1 в corobus.h.
  Тесты должны пройти. В corobus.h вы найдете эти функции и
  описания того, что они должны делать.

- -5 баллов: (да, минус, не плюс) - можно использовать C++ и STL
  контейнеры.

Добавочные пункты на +5 баллов друг друга не включают. То есть
можно не делать ни одного, можно сделать первый, или второй, или
оба для +10. Или использовать C++ и получать -5 к сумме.
